% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cvAlpha.R
\name{cvAlpha.gamlr}
\alias{coef.cvAlpha.gamlr}
\alias{cvAlpha.gamlr}
\alias{cvAlpha.gamlr.default}
\alias{cvAlpha.gamlr.formula}
\alias{plot.cvAlpha.gamlr}
\alias{plotLambda}
\alias{predict.cvAlpha.gamlr}
\alias{predict.cvAlpha.gamlr.formula}
\title{Do elastic net cross-validation for alpha and lambda simultaneously}
\usage{
cvAlpha.gamlr(x, ...)

\method{cvAlpha.gamlr}{default}(x, y, alpha = seq(0, 1, len = 11)^3,
  nfolds = 10, ..., outerParallel = NULL, checkInnerParallel = TRUE)

\method{cvAlpha.gamlr}{formula}(formula, data, ..., weights, offset = NULL,
  subset = NULL, na.action = getOption("na.action"),
  drop.unused.levels = FALSE, xlev = NULL, sparse = FALSE)

\method{predict}{cvAlpha.gamlr}(object, newx, alpha, which = match(TRUE,
  abs(object$alpha - alpha) < 1e-08), ...)

\method{predict}{cvAlpha.gamlr.formula}(object, newdata, alpha,
  which = match(TRUE, abs(object$alpha - alpha) < 1e-08),
  na.action = na.pass, ...)

\method{coef}{cvAlpha.gamlr}(object, alpha, which = match(TRUE,
  abs(object$alpha - alpha) < 1e-08), ...)

\method{plot}{cvAlpha.gamlr}(x, ...)

plotLambda(x, ...)
}
\arguments{
\item{x}{A matrix of predictor variables; or for the plotting methods, an object returned by \code{cvAlpha.gamlr}.}

\item{...}{Further arguments to be passed to lower-level functions. In the case of \code{cvAlpha.gamlr}, these arguments are passed to \code{cv.gamlr}; for \code{predict} and \code{coef}, they are passed to \code{predict.cv.gamlr}; and for \code{plot} and \code{plotLambda}, to \code{plot}.}

\item{y}{A response vector or matrix (for a multinomial response).}

\item{alpha}{A vector of alpha values for which to do cross-validation. The default is a sequence of 11 values more closely spaced around alpha = 0. For the \code{predict} and \code{coef} methods, the specific value of alpha for which to return predictions/regression coefficients.}

\item{nfolds}{The number of cross-validation folds to use. Defaults to 10.}

\item{outerParallel}{Method of parallelising the outer loop over alpha. See 'Details' below. If \code{NULL}, the loop is run sequentially.}

\item{checkInnerParallel}{If the outer loop is run in parallel, check that the inner loop over lambda will not be in contention for cores.}

\item{formula}{A model formula; interaction terms are allowed and will be expanded per the usual rules for linear models.}

\item{data}{A data frame or matrix containing the variables in the formula.}

\item{weights}{An optional vector of case weights to be used in the fitting process. If missing, defaults to an unweighted fit.}

\item{offset}{An optional vector of offsets, an \emph{a priori} known component to be included in the linear predictor.}

\item{subset}{An optional vector specifying the subset of observations to be used to fit the model.}

\item{na.action}{A function which indicates what should happen when the data contains missing values. For the \code{predict} method, \code{na.action = na.pass} will predict missing values with \code{NA}; \code{na.omit} or \code{na.exclude} will drop them.}

\item{drop.unused.levels}{Should factors have unused levels dropped? Defaults to \code{FALSE}.}

\item{xlev}{A named list of character vectors giving the full set of levels to be assumed for each factor.}

\item{sparse}{Should the model matrix be in sparse format? This can save memory when dealing with many factor variables, each with many levels (but see the warning below).}

\item{object}{For the \code{predict} and \code{coef} methods, an object returned by \code{cvAlpha.gamlr}.}

\item{newx}{For the \code{predict} method, a matrix of predictor variables.}

\item{which}{An alternative way of specifying alpha; the index number of the desired value within the alpha vector. If both \code{which} and \code{alpha} are supplied, the former takes precedence.}

\item{newdata}{For the \code{predict} and \code{coef} methods, a data frame containing the observations for which to calculate predictions.}
}
\description{
Do elastic net cross-validation for alpha and lambda simultaneously
}
\details{
The \code{cvAlpha.gamlr} function does simultaneous cross-validation for both the alpha and lambda parameters in an elastic net model. It follows the procedure outlined in the documentation for \code{\link[gamlr:cv.gamlr]{gamlr::cv.gamlr}}: it creates a vector \code{foldid} allocating the observations into folds, and then calls \code{cv.gamlr} in a loop over different values of alpha, but the same values of \code{foldid} each time.

Optionally this loop over alpha can be parallelised; currently, \code{cvAlpha.gamlr} knows about two methods of doing so:
\itemize{
  \item Via \code{\link{parLapply}} in the \code{parallel} package. To use this, set \code{outerParallel} to a valid cluster object created by \code{\link{makeCluster}}.
  \item Via \code{\link{rxExec}} as supplied by Microsoft R Server's \code{RevoScaleR} package. To use this, set \code{outerParallel} to a valid compute context created by \code{\link{RxComputeContext}}, or a character string specifying such a context.
}
If the outer loop is run in parallel, \code{cvAlpha.gamlr} can check if the inner loop (over lambda) is also set to run in parallel, and disable this if it would lead to contention for cores. This is done if it is likely that the parallelisation is local on a multicore machine, ie if \code{outerParallel} is a \code{SOCKcluster} object running on \code{"localhost"}, or if the supplied compute context is local parallel.

The formula method works in a similar manner to \code{lm}, \code{glm} and other modelling functions. The arguments are used to generate a \emph{model frame}, which is a data frame augmented with information about the roles the columns play in fitting the model. This is then turned into a \emph{model matrix} and a response vector, which are passed to \code{gamlr::gamlr} along with any arguments in \code{...}. If \code{sparse} is TRUE, then \code{Matrix::sparse.model.matrix} is used instead of \code{stats::model.matrix} to create the model matrix.

The \code{predict} method computes predictions for a specific alpha value given a \code{cvAlpha.gamlr} object. It looks up the supplied alpha (possibly supplied indirectly via the \code{which} argument) in the object's stored \code{alpha} vector, and calls \code{gamlr:::predict.cv.gamlr} on the corresponding \code{cv.gamlr} fit. All the arguments to that function are (or should be) supported.

The \code{coef} method is similar, returning the coefficients for the selected alpha value via \code{gamlr:::coef.cv.gamlr}.

The plot method for \code{cvAlpha.gamlr} objects plots the average cross-validated loss by lambda, for each value of alpha. Each line represents one \code{cv.gamlr} fit, corresponding to one value of alpha. Note that the specific lambda values can vary substantially by alpha, hence no attempt is made to put them on a common scale. Instead, the lines are simply the cross-validated loss results in sequential order, with the smallest lambda values for each fit on the left.

The \code{plotLambda} function gives the best (lowest) cross-validated loss for each value of alpha.
}
\section{Value}{

For \code{cvAlpha.gamlr.default}, an object of class \code{cvAlpha.gamlr}. This is a list containing the following:
\itemize{
  \item \code{alpha} The vector of alpha values
  \item \code{nfolds} The number of folds
  \item \code{modlist} A list of \code{cv.gamlr} objects, containing the cross-validation results for each value of alpha
}
The function \code{cvAlpha.gamlr.formula} adds a few more components to the above, to facilitate working with formulas.


For the \code{predict} method, a vector or matrix of predicted values.


For the \code{coef} method, a vector of regularised regression coefficients.
}

\section{Warning}{

Fundamental to R's handling of formulas, model frames and model matrices is a \code{\link{terms}} object, which encodes how variables and their interactions (if any) are organised. One of the attributes of this object is a matrix with one row per variable, and one column per main effect and interaction. Thus, at minimum, this is (approximately) a \eqn{p \times p}{p x p} square matrix where \eqn{p} is the number of main effects in the model. When \eqn{p ~ 16000}, this matrix will be about a gigabyte in size. Because of this, you should use the formula interface with caution when working with wide datasets and limited memory.
}
\examples{
cva <- cvAlpha.gamlr(mpg ~ ., data=mtcars)
predict(cva, mtcars, alpha=1)

\dontrun{

# Leukemia example dataset from Trevor Hastie's website
download.file("http://web.stanford.edu/~hastie/gamlr/gamlrData/Leukemia.RData",
              "Leukemia.RData")
load("Leukemia.Rdata")
leuk <- do.call(data.frame, Leukemia)
leuk.cva <- cvAlpha.gamlr(y ~ ., leuk, family="binomial")
leuk.pred <- predict(leuk.cva, leuk, which=6)
}
}
\seealso{
\code{\link[gamlr:cv.gamlr]{gamlr::cv.gamlr}}

\code{\link[gamlr:predict.cv.gamlr]{gamlr:::predict.cv.gamlr}}, \code{\link[gamlr:coef.cv.gamlr]{gamlr:::coef.cv.gamlr}}

\code{\link{cvAlpha.gamlr}}, \code{\link[gamlr:cv.gamlr]{gamlr::cv.gamlr}}, \code{\link{plot}}
}

